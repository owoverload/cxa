{"ast":null,"code":"'use strict';\n\nvar asap = require('asap');\n\nvar PENDING = 0,\n    FULFILLED = 1,\n    REJECTED = 2;\n\nvar RETURN = function (x) {\n  return x;\n},\n    THROW = function (x) {\n  throw x;\n};\n\nvar Promise = function (task) {\n  this._state = PENDING;\n  this._onFulfilled = [];\n  this._onRejected = [];\n  if (typeof task !== 'function') return;\n  var self = this;\n  task(function (value) {\n    resolve(self, value);\n  }, function (reason) {\n    reject(self, reason);\n  });\n};\n\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  var next = new Promise();\n  registerOnFulfilled(this, onFulfilled, next);\n  registerOnRejected(this, onRejected, next);\n  return next;\n};\n\nPromise.prototype['catch'] = function (onRejected) {\n  return this.then(null, onRejected);\n};\n\nvar registerOnFulfilled = function (promise, onFulfilled, next) {\n  if (typeof onFulfilled !== 'function') onFulfilled = RETURN;\n\n  var handler = function (value) {\n    invoke(onFulfilled, value, next);\n  };\n\n  if (promise._state === PENDING) {\n    promise._onFulfilled.push(handler);\n  } else if (promise._state === FULFILLED) {\n    handler(promise._value);\n  }\n};\n\nvar registerOnRejected = function (promise, onRejected, next) {\n  if (typeof onRejected !== 'function') onRejected = THROW;\n\n  var handler = function (reason) {\n    invoke(onRejected, reason, next);\n  };\n\n  if (promise._state === PENDING) {\n    promise._onRejected.push(handler);\n  } else if (promise._state === REJECTED) {\n    handler(promise._reason);\n  }\n};\n\nvar invoke = function (fn, value, next) {\n  asap(function () {\n    _invoke(fn, value, next);\n  });\n};\n\nvar _invoke = function (fn, value, next) {\n  var outcome;\n\n  try {\n    outcome = fn(value);\n  } catch (error) {\n    return reject(next, error);\n  }\n\n  if (outcome === next) {\n    reject(next, new TypeError('Recursive promise chain detected'));\n  } else {\n    resolve(next, outcome);\n  }\n};\n\nvar resolve = function (promise, value) {\n  var called = false,\n      type,\n      then;\n\n  try {\n    type = typeof value;\n    then = value !== null && (type === 'function' || type === 'object') && value.then;\n    if (typeof then !== 'function') return fulfill(promise, value);\n    then.call(value, function (v) {\n      if (!(called ^ (called = true))) return;\n      resolve(promise, v);\n    }, function (r) {\n      if (!(called ^ (called = true))) return;\n      reject(promise, r);\n    });\n  } catch (error) {\n    if (!(called ^ (called = true))) return;\n    reject(promise, error);\n  }\n};\n\nvar fulfill = function (promise, value) {\n  if (promise._state !== PENDING) return;\n  promise._state = FULFILLED;\n  promise._value = value;\n  promise._onRejected = [];\n  var onFulfilled = promise._onFulfilled,\n      fn;\n\n  while (fn = onFulfilled.shift()) fn(value);\n};\n\nvar reject = function (promise, reason) {\n  if (promise._state !== PENDING) return;\n  promise._state = REJECTED;\n  promise._reason = reason;\n  promise._onFulfilled = [];\n  var onRejected = promise._onRejected,\n      fn;\n\n  while (fn = onRejected.shift()) fn(reason);\n};\n\nPromise.resolve = function (value) {\n  return new Promise(function (resolve, reject) {\n    resolve(value);\n  });\n};\n\nPromise.reject = function (reason) {\n  return new Promise(function (resolve, reject) {\n    reject(reason);\n  });\n};\n\nPromise.all = function (promises) {\n  return new Promise(function (resolve, reject) {\n    var list = [],\n        n = promises.length,\n        i;\n    if (n === 0) return resolve(list);\n\n    for (i = 0; i < n; i++) (function (promise, i) {\n      Promise.resolve(promise).then(function (value) {\n        list[i] = value;\n        if (--n === 0) resolve(list);\n      }, reject);\n    })(promises[i], i);\n  });\n};\n\nPromise.race = function (promises) {\n  return new Promise(function (resolve, reject) {\n    for (var i = 0, n = promises.length; i < n; i++) Promise.resolve(promises[i]).then(resolve, reject);\n  });\n};\n\nPromise.deferred = Promise.pending = function () {\n  var tuple = {};\n  tuple.promise = new Promise(function (resolve, reject) {\n    tuple.resolve = resolve;\n    tuple.reject = reject;\n  });\n  return tuple;\n};\n\nmodule.exports = Promise;","map":null,"metadata":{},"sourceType":"script"}