{"ast":null,"code":"// Browser Request\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar XHR = XMLHttpRequest;\nif (!XHR) throw new Error('missing XMLHttpRequest');\nrequest.log = {\n  'trace': noop,\n  'debug': noop,\n  'info': noop,\n  'warn': noop,\n  'error': noop\n};\nvar DEFAULT_TIMEOUT = 3 * 60 * 1000; // 3 minutes\n//\n// PolyFill\n// \n// Production steps of ECMA-262, Edition 5, 15.4.4.18\n// Reference: http://es5.github.io/#x15.4.4.18\n\nif (!Array.prototype.forEach) {\n  Array.prototype.forEach = function (callback, thisArg) {\n    var T, k;\n\n    if (this === null) {\n      throw new TypeError(' this is null or not defined');\n    } // 1. Let O be the result of calling toObject() passing the\n    // |this| value as the argument.\n\n\n    var O = Object(this); // 2. Let lenValue be the result of calling the Get() internal\n    // method of O with the argument \"length\".\n    // 3. Let len be toUint32(lenValue).\n\n    var len = O.length >>> 0; // 4. If isCallable(callback) is false, throw a TypeError exception. \n    // See: http://es5.github.com/#x9.11\n\n    if (typeof callback !== \"function\") {\n      throw new TypeError(callback + ' is not a function');\n    } // 5. If thisArg was supplied, let T be thisArg; else let\n    // T be undefined.\n\n\n    if (arguments.length > 1) {\n      T = thisArg;\n    } // 6. Let k be 0\n\n\n    k = 0; // 7. Repeat, while k < len\n\n    while (k < len) {\n      var kValue; // a. Let Pk be ToString(k).\n      //    This is implicit for LHS operands of the in operator\n      // b. Let kPresent be the result of calling the HasProperty\n      //    internal method of O with argument Pk.\n      //    This step can be combined with c\n      // c. If kPresent is true, then\n\n      if (k in O) {\n        // i. Let kValue be the result of calling the Get internal\n        // method of O with argument Pk.\n        kValue = O[k]; // ii. Call the Call internal method of callback with T as\n        // the this value and argument list containing kValue, k, and O.\n\n        callback.call(T, kValue, k, O);\n      } // d. Increase k by 1.\n\n\n      k++;\n    } // 8. return undefined\n\n  };\n} //\n// request\n//\n\n\nfunction request(options, callback) {\n  // The entry-point to the API: prep the options object and pass the real work to run_xhr.\n  if (typeof callback !== 'function') throw new Error('Bad callback given: ' + callback);\n  if (!options) throw new Error('No options given');\n  var options_onResponse = options.onResponse; // Save this for later.\n\n  if (typeof options === 'string') options = {\n    'uri': options\n  };else options = JSON.parse(JSON.stringify(options)); // Use a duplicate for mutating.\n\n  options.onResponse = options_onResponse; // And put it back.\n\n  if (options.verbose) request.log = getLogger();\n\n  if (options.url) {\n    options.uri = options.url;\n    delete options.url;\n  }\n\n  if (!options.uri && options.uri !== \"\") throw new Error(\"options.uri is a required argument\");\n  if (typeof options.uri != \"string\") throw new Error(\"options.uri must be a string\");\n  var unsupported_options = ['proxy', '_redirectsFollowed', 'maxRedirects', 'followRedirect'];\n\n  for (var i = 0; i < unsupported_options.length; i++) if (options[unsupported_options[i]]) throw new Error(\"options.\" + unsupported_options[i] + \" is not supported\");\n\n  options.callback = callback;\n  options.method = options.method || 'GET';\n  options.headers = options.headers || {};\n  options.body = options.body || null;\n  options.timeout = options.timeout || request.DEFAULT_TIMEOUT;\n  if (options.headers.host) throw new Error(\"Options.headers.host is not supported\");\n\n  if (options.json) {\n    options.headers.accept = options.headers.accept || 'application/json';\n    if (options.method !== 'GET') options.headers['content-type'] = 'application/json';\n    if (typeof options.json !== 'boolean') options.body = JSON.stringify(options.json);else if (typeof options.body !== 'string' && options.body !== null) options.body = JSON.stringify(options.body);\n  } //BEGIN QS Hack\n\n\n  var serialize = function (obj) {\n    var str = [];\n\n    for (var p in obj) if (obj.hasOwnProperty(p)) {\n      str.push(encodeURIComponent(p) + \"=\" + encodeURIComponent(obj[p]));\n    }\n\n    return str.join(\"&\");\n  };\n\n  if (options.qs) {\n    var qs = typeof options.qs == 'string' ? options.qs : serialize(options.qs);\n\n    if (options.uri.indexOf('?') !== -1) {\n      //no get params\n      options.uri = options.uri + '&' + qs;\n    } else {\n      //existing get params\n      options.uri = options.uri + '?' + qs;\n    }\n  } //END QS Hack\n  //BEGIN FORM Hack\n\n\n  var multipart = function (obj) {\n    //todo: support file type (useful?)\n    var result = {};\n    result.boundry = '-------------------------------' + Math.floor(Math.random() * 1000000000);\n    var lines = [];\n\n    for (var p in obj) {\n      if (obj.hasOwnProperty(p)) {\n        lines.push('--' + result.boundry + \"\\n\" + 'Content-Disposition: form-data; name=\"' + p + '\"' + \"\\n\" + \"\\n\" + obj[p] + \"\\n\");\n      }\n    }\n\n    lines.push('--' + result.boundry + '--');\n    result.body = lines.join('');\n    result.length = result.body.length;\n    result.type = 'multipart/form-data; boundary=' + result.boundry;\n    return result;\n  };\n\n  if (options.form) {\n    if (typeof options.form == 'string') throw 'form name unsupported';\n\n    if (options.method === 'POST') {\n      var encoding = (options.encoding || 'application/x-www-form-urlencoded').toLowerCase();\n      options.headers['content-type'] = encoding;\n\n      switch (encoding) {\n        case 'application/x-www-form-urlencoded':\n          options.body = serialize(options.form).replace(/%20/g, \"+\");\n          break;\n\n        case 'multipart/form-data':\n          var multi = multipart(options.form); //options.headers['content-length'] = multi.length;\n\n          options.body = multi.body;\n          options.headers['content-type'] = multi.type;\n          break;\n\n        default:\n          throw new Error('unsupported encoding:' + encoding);\n      }\n    }\n  } //END FORM Hack\n  // If onResponse is boolean true, call back immediately when the response is known,\n  // not when the full request is complete.\n\n\n  options.onResponse = options.onResponse || noop;\n\n  if (options.onResponse === true) {\n    options.onResponse = callback;\n    options.callback = noop;\n  } // XXX Browsers do not like this.\n  //if(options.body)\n  //  options.headers['content-length'] = options.body.length;\n  // HTTP basic authentication\n\n\n  if (!options.headers.authorization && options.auth) options.headers.authorization = 'Basic ' + b64_enc(options.auth.username + ':' + options.auth.password);\n  return run_xhr(options);\n}\n\nvar req_seq = 0;\n\nfunction run_xhr(options) {\n  var xhr = new XHR(),\n      timed_out = false,\n      is_cors = is_crossDomain(options.uri),\n      supports_cors = 'withCredentials' in xhr;\n  req_seq += 1;\n  xhr.seq_id = req_seq;\n  xhr.id = req_seq + ': ' + options.method + ' ' + options.uri;\n  xhr._id = xhr.id; // I know I will type \"_id\" from habit all the time.\n\n  if (is_cors && !supports_cors) {\n    var cors_err = new Error('Browser does not support cross-origin request: ' + options.uri);\n    cors_err.cors = 'unsupported';\n    return options.callback(cors_err, xhr);\n  }\n\n  xhr.timeoutTimer = setTimeout(too_late, options.timeout);\n\n  function too_late() {\n    timed_out = true;\n    var er = new Error('ETIMEDOUT');\n    er.code = 'ETIMEDOUT';\n    er.duration = options.timeout;\n    request.log.error('Timeout', {\n      'id': xhr._id,\n      'milliseconds': options.timeout\n    });\n    return options.callback(er, xhr);\n  } // Some states can be skipped over, so remember what is still incomplete.\n\n\n  var did = {\n    'response': false,\n    'loading': false,\n    'end': false\n  };\n  xhr.onreadystatechange = on_state_change;\n  xhr.open(options.method, options.uri, true); // asynchronous\n\n  if (is_cors) xhr.withCredentials = !!options.withCredentials;\n\n  for (var key in options.headers) xhr.setRequestHeader(key, options.headers[key]);\n\n  xhr.send(options.body);\n  return xhr;\n\n  function on_state_change(event) {\n    if (timed_out) return request.log.debug('Ignoring timed out state change', {\n      'state': xhr.readyState,\n      'id': xhr.id\n    });\n    request.log.debug('State change', {\n      'state': xhr.readyState,\n      'id': xhr.id,\n      'timed_out': timed_out\n    });\n\n    if (xhr.readyState === 1) {\n      request.log.debug('Request started', {\n        'id': xhr.id\n      });\n    } else if (xhr.readyState === 2) on_response();else if (xhr.readyState === 3) {\n      on_response();\n      on_loading();\n    } else if (xhr.readyState === 4) {\n      on_response();\n      on_loading();\n      on_end();\n    }\n  }\n\n  function on_response() {\n    if (did.response) return;\n    did.response = true;\n    request.log.debug('Got response', {\n      'id': xhr.id,\n      'status': xhr.status\n    });\n    clearTimeout(xhr.timeoutTimer);\n    xhr.statusCode = xhr.status; // Node request compatibility\n    // Detect failed CORS requests.\n\n    if (is_cors && xhr.statusCode == 0) {\n      var cors_err = new Error('CORS request rejected: ' + options.uri);\n      cors_err.cors = 'rejected'; // Do not process this request further.\n\n      did.loading = true;\n      did.end = true;\n      return options.callback(cors_err, xhr);\n    }\n\n    options.onResponse(null, xhr);\n  }\n\n  function on_loading() {\n    if (did.loading) return;\n    did.loading = true;\n    request.log.debug('Response body loading', {\n      'id': xhr.id\n    }); // TODO: Maybe simulate \"data\" events by watching xhr.responseText\n  }\n\n  function on_end() {\n    if (did.end) return;\n    did.end = true;\n    request.log.debug('Request done', {\n      'id': xhr.id\n    });\n    xhr.body = xhr.responseText;\n\n    if (options.json) {\n      try {\n        xhr.body = JSON.parse(xhr.responseText);\n      } catch (er) {\n        return options.callback(er, xhr);\n      }\n    }\n\n    options.callback(null, xhr, xhr.body);\n  }\n} // request\n\n\nrequest.withCredentials = false;\nrequest.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT; //\n// defaults\n//\n\nrequest.defaults = function (options, requester) {\n  var def = function (method) {\n    var d = function (params, callback) {\n      if (typeof params === 'string') params = {\n        'uri': params\n      };else {\n        params = JSON.parse(JSON.stringify(params));\n      }\n\n      for (var i in options) {\n        if (params[i] === undefined) params[i] = options[i];\n      }\n\n      return method(params, callback);\n    };\n\n    return d;\n  };\n\n  var de = def(request);\n  de.get = def(request.get);\n  de.post = def(request.post);\n  de.put = def(request.put);\n  de.head = def(request.head);\n  return de;\n}; //\n// HTTP method shortcuts\n//\n\n\nvar shortcuts = ['get', 'put', 'post', 'head'];\nshortcuts.forEach(function (shortcut) {\n  var method = shortcut.toUpperCase();\n  var func = shortcut.toLowerCase();\n\n  request[func] = function (opts) {\n    if (typeof opts === 'string') opts = {\n      'method': method,\n      'uri': opts\n    };else {\n      opts = JSON.parse(JSON.stringify(opts));\n      opts.method = method;\n    }\n    var args = [opts].concat(Array.prototype.slice.apply(arguments, [1]));\n    return request.apply(this, args);\n  };\n}); //\n// CouchDB shortcut\n//\n\nrequest.couch = function (options, callback) {\n  if (typeof options === 'string') options = {\n    'uri': options // Just use the request API to do JSON.\n\n  };\n  options.json = true;\n  if (options.body) options.json = options.body;\n  delete options.body;\n  callback = callback || noop;\n  var xhr = request(options, couch_handler);\n  return xhr;\n\n  function couch_handler(er, resp, body) {\n    if (er) return callback(er, resp, body);\n\n    if ((resp.statusCode < 200 || resp.statusCode > 299) && body.error) {\n      // The body is a Couch JSON object indicating the error.\n      er = new Error('CouchDB error: ' + (body.error.reason || body.error.error));\n\n      for (var key in body) er[key] = body[key];\n\n      return callback(er, resp, body);\n    }\n\n    return callback(er, resp, body);\n  }\n}; //\n// Utility\n//\n\n\nfunction noop() {}\n\nfunction getLogger() {\n  var logger = {},\n      levels = ['trace', 'debug', 'info', 'warn', 'error'],\n      level,\n      i;\n\n  for (i = 0; i < levels.length; i++) {\n    level = levels[i];\n    logger[level] = noop;\n    if (typeof console !== 'undefined' && console && console[level]) logger[level] = formatted(console, level);\n  }\n\n  return logger;\n}\n\nfunction formatted(obj, method) {\n  return formatted_logger;\n\n  function formatted_logger(str, context) {\n    if (typeof context === 'object') str += ' ' + JSON.stringify(context);\n    return obj[method].call(obj, str);\n  }\n} // Return whether a URL is a cross-domain request.\n\n\nfunction is_crossDomain(url) {\n  // Fix for React Native. CORS does noet exist in that environment\n  if (navigator && navigator.product === 'ReactNative') {\n    return false;\n  }\n\n  var rurl = /^([\\w\\+\\.\\-]+:)(?:\\/\\/([^\\/?#:]*)(?::(\\d+))?)?/; // jQuery #8138, IE may throw an exception when accessing\n  // a field from window.location if document.domain has been set\n\n  var ajaxLocation;\n\n  try {\n    ajaxLocation = location.href;\n  } catch (e) {\n    // Use the href attribute of an A element since IE will modify it given document.location\n    ajaxLocation = document.createElement(\"a\");\n    ajaxLocation.href = \"\";\n    ajaxLocation = ajaxLocation.href;\n  }\n\n  var ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [],\n      parts = rurl.exec(url.toLowerCase());\n  var result = !!(parts && (parts[1] != ajaxLocParts[1] || parts[2] != ajaxLocParts[2] || (parts[3] || (parts[1] === \"http:\" ? 80 : 443)) != (ajaxLocParts[3] || (ajaxLocParts[1] === \"http:\" ? 80 : 443)))); //console.debug('is_crossDomain('+url+') -> ' + result)\n\n  return result;\n} // MIT License from http://phpjs.org/functions/base64_encode:358\n\n\nfunction b64_enc(data) {\n  // Encodes string using MIME base64 algorithm\n  var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n  var o1,\n      o2,\n      o3,\n      h1,\n      h2,\n      h3,\n      h4,\n      bits,\n      i = 0,\n      ac = 0,\n      enc = \"\",\n      tmp_arr = [];\n\n  if (!data) {\n    return data;\n  } // assume utf8 data\n  // data = this.utf8_encode(data+'');\n\n\n  do {\n    // pack three octets into four hexets\n    o1 = data.charCodeAt(i++);\n    o2 = data.charCodeAt(i++);\n    o3 = data.charCodeAt(i++);\n    bits = o1 << 16 | o2 << 8 | o3;\n    h1 = bits >> 18 & 0x3f;\n    h2 = bits >> 12 & 0x3f;\n    h3 = bits >> 6 & 0x3f;\n    h4 = bits & 0x3f; // use hexets to index into b64, and append result to encoded string\n\n    tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);\n  } while (i < data.length);\n\n  enc = tmp_arr.join('');\n\n  switch (data.length % 3) {\n    case 1:\n      enc = enc.slice(0, -2) + '==';\n      break;\n\n    case 2:\n      enc = enc.slice(0, -1) + '=';\n      break;\n  }\n\n  return enc;\n}\n\nmodule.exports = request;","map":null,"metadata":{},"sourceType":"script"}