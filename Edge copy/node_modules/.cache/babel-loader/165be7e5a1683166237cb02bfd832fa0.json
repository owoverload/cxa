{"ast":null,"code":"'use strict';\n\nvar Class = require('../util/class'),\n    Cookie = require('../util/cookies').Cookie,\n    Promise = require('../util/promise'),\n    URI = require('../util/uri'),\n    array = require('../util/array'),\n    extend = require('../util/extend'),\n    Logging = require('../mixins/logging'),\n    Timeouts = require('../mixins/timeouts'),\n    Channel = require('../protocol/channel');\n\nvar Transport = extend(Class({\n  className: 'Transport',\n  DEFAULT_PORTS: {\n    'http:': 80,\n    'https:': 443,\n    'ws:': 80,\n    'wss:': 443\n  },\n  MAX_DELAY: 0,\n  batching: true,\n  initialize: function (dispatcher, endpoint) {\n    this._dispatcher = dispatcher;\n    this.endpoint = endpoint;\n    this._outbox = [];\n    this._proxy = extend({}, this._dispatcher.proxy);\n    if (!this._proxy.origin) this._proxy.origin = this._findProxy();\n  },\n  close: function () {},\n  encode: function (messages) {\n    return '';\n  },\n  sendMessage: function (message) {\n    this.debug('Client ? sending message to ?: ?', this._dispatcher.clientId, URI.stringify(this.endpoint), message);\n    if (!this.batching) return Promise.resolve(this.request([message]));\n\n    this._outbox.push(message);\n\n    this._flushLargeBatch();\n\n    if (message.channel === Channel.HANDSHAKE) return this._publish(0.01);\n    if (message.channel === Channel.CONNECT) this._connectMessage = message;\n    return this._publish(this.MAX_DELAY);\n  },\n  _makePromise: function () {\n    var self = this;\n    this._requestPromise = this._requestPromise || new Promise(function (resolve) {\n      self._resolvePromise = resolve;\n    });\n  },\n  _publish: function (delay) {\n    this._makePromise();\n\n    this.addTimeout('publish', delay, function () {\n      this._flush();\n\n      delete this._requestPromise;\n    }, this);\n    return this._requestPromise;\n  },\n  _flush: function () {\n    this.removeTimeout('publish');\n    if (this._outbox.length > 1 && this._connectMessage) this._connectMessage.advice = {\n      timeout: 0\n    };\n\n    this._resolvePromise(this.request(this._outbox));\n\n    this._connectMessage = null;\n    this._outbox = [];\n  },\n  _flushLargeBatch: function () {\n    var string = this.encode(this._outbox);\n    if (string.length < this._dispatcher.maxRequestSize) return;\n\n    var last = this._outbox.pop();\n\n    this._makePromise();\n\n    this._flush();\n\n    if (last) this._outbox.push(last);\n  },\n  _receive: function (replies) {\n    if (!replies) return;\n    replies = [].concat(replies);\n    this.debug('Client ? received from ? via ?: ?', this._dispatcher.clientId, URI.stringify(this.endpoint), this.connectionType, replies);\n\n    for (var i = 0, n = replies.length; i < n; i++) this._dispatcher.handleResponse(replies[i]);\n  },\n  _handleError: function (messages, immediate) {\n    messages = [].concat(messages);\n    this.debug('Client ? failed to send to ? via ?: ?', this._dispatcher.clientId, URI.stringify(this.endpoint), this.connectionType, messages);\n\n    for (var i = 0, n = messages.length; i < n; i++) this._dispatcher.handleError(messages[i]);\n  },\n  _getCookies: function () {\n    var cookies = this._dispatcher.cookies,\n        url = URI.stringify(this.endpoint);\n    if (!cookies) return '';\n    return array.map(cookies.getCookiesSync(url), function (cookie) {\n      return cookie.cookieString();\n    }).join('; ');\n  },\n  _storeCookies: function (setCookie) {\n    var cookies = this._dispatcher.cookies,\n        url = URI.stringify(this.endpoint),\n        cookie;\n    if (!setCookie || !cookies) return;\n    setCookie = [].concat(setCookie);\n\n    for (var i = 0, n = setCookie.length; i < n; i++) {\n      cookie = Cookie.parse(setCookie[i]);\n      cookies.setCookieSync(cookie, url);\n    }\n  },\n  _findProxy: function () {\n    if (typeof process === 'undefined') return undefined;\n    var protocol = this.endpoint.protocol;\n    if (!protocol) return undefined;\n    var name = protocol.replace(/:$/, '').toLowerCase() + '_proxy',\n        upcase = name.toUpperCase(),\n        env = process.env,\n        keys,\n        proxy;\n\n    if (name === 'http_proxy' && env.REQUEST_METHOD) {\n      keys = Object.keys(env).filter(function (k) {\n        return /^http_proxy$/i.test(k);\n      });\n\n      if (keys.length === 1) {\n        if (keys[0] === name && env[upcase] === undefined) proxy = env[name];\n      } else if (keys.length > 1) {\n        proxy = env[name];\n      }\n\n      proxy = proxy || env['CGI_' + upcase];\n    } else {\n      proxy = env[name] || env[upcase];\n      if (proxy && !env[name]) console.warn('The environment variable ' + upcase + ' is discouraged. Use ' + name + '.');\n    }\n\n    return proxy;\n  }\n}), {\n  get: function (dispatcher, allowed, disabled, callback, context) {\n    var endpoint = dispatcher.endpoint;\n    array.asyncEach(this._transports, function (pair, resume) {\n      var connType = pair[0],\n          klass = pair[1],\n          connEndpoint = dispatcher.endpointFor(connType);\n      if (array.indexOf(disabled, connType) >= 0) return resume();\n\n      if (array.indexOf(allowed, connType) < 0) {\n        klass.isUsable(dispatcher, connEndpoint, function () {});\n        return resume();\n      }\n\n      klass.isUsable(dispatcher, connEndpoint, function (isUsable) {\n        if (!isUsable) return resume();\n        var transport = klass.hasOwnProperty('create') ? klass.create(dispatcher, connEndpoint) : new klass(dispatcher, connEndpoint);\n        callback.call(context, transport);\n      });\n    }, function () {\n      throw new Error('Could not find a usable connection type for ' + URI.stringify(endpoint));\n    });\n  },\n  register: function (type, klass) {\n    this._transports.push([type, klass]);\n\n    klass.prototype.connectionType = type;\n  },\n  getConnectionTypes: function () {\n    return array.map(this._transports, function (t) {\n      return t[0];\n    });\n  },\n  _transports: []\n});\nextend(Transport.prototype, Logging);\nextend(Transport.prototype, Timeouts);\nmodule.exports = Transport;","map":null,"metadata":{},"sourceType":"script"}