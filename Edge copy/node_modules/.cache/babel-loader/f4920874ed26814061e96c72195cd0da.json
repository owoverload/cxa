{"ast":null,"code":"/*\nCopyright Joyent, Inc. and other Node contributors. All rights reserved.\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nvar isArray = typeof Array.isArray === 'function' ? Array.isArray : function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction indexOf(xs, x) {\n  if (xs.indexOf) return xs.indexOf(x);\n\n  for (var i = 0; i < xs.length; i++) {\n    if (x === xs[i]) return i;\n  }\n\n  return -1;\n}\n\nfunction EventEmitter() {}\n\nmodule.exports = EventEmitter;\n\nEventEmitter.prototype.emit = function (type) {\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events || !this._events.error || isArray(this._events.error) && !this._events.error.length) {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == 'function') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n\n    return true;\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    var listeners = handler.slice();\n\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n\n    return true;\n  } else {\n    return false;\n  }\n}; // EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\n\n\nEventEmitter.prototype.addListener = function (type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('addListener only takes instances of Function');\n  }\n\n  if (!this._events) this._events = {}; // To avoid recursion in the case that type == \"newListeners\"! Before\n  // adding it to the listeners, first emit \"newListeners\".\n\n  this.emit('newListener', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function (type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function (type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('removeListener only takes instances of Function');\n  } // does not use listeners(), so no side effect of creating _events[type]\n\n\n  if (!this._events || !this._events[type]) return this;\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = indexOf(list, listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0) delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function (type) {\n  if (arguments.length === 0) {\n    this._events = {};\n    return this;\n  } // does not use listeners(), so no side effect of creating _events[type]\n\n\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\nEventEmitter.prototype.listeners = function (type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n\n  return this._events[type];\n};","map":null,"metadata":{},"sourceType":"script"}