{"ast":null,"code":"var _extends = require(\"@babel/runtime/helpers/extends\");\n\nvar _typeof = require(\"@babel/runtime/helpers/typeof\");\n\nvar errors = require('./errors');\n\nvar utils = require('./utils');\n\nvar isObject = require('lodash/isObject');\n\nvar isPlainObject = require('lodash/isPlainObject');\n\nvar StreamUser = require('./user');\n\nvar signing = require('./signing');\n\nvar StreamFeed = function StreamFeed() {\n  /**\n   * Manage api calls for specific feeds\n   * The feed object contains convenience functions such add activity, remove activity etc\n   * @class StreamFeed\n   */\n  this.initialize.apply(this, arguments);\n};\n\nfunction replaceStreamObjects(obj) {\n  var cloned = obj;\n\n  if (Array.isArray(obj)) {\n    cloned = obj.map(function (v) {\n      return replaceStreamObjects(v);\n    });\n  } else if (isPlainObject(obj)) {\n    cloned = {};\n\n    for (var k in obj) {\n      cloned[k] = replaceStreamObjects(obj[k]);\n    }\n  } else if (isObject(obj) && obj._streamRef !== undefined) {\n    cloned = obj._streamRef();\n  }\n\n  return cloned;\n}\n\nStreamFeed.prototype = {\n  initialize: function initialize(client, feedSlug, userId, token) {\n    /**\n     * Initialize a feed object\n     * @method intialize\n     * @memberof StreamFeed.prototype\n     * @param {StreamClient} client - The stream client this feed is constructed from\n     * @param {string} feedSlug - The feed slug\n     * @param {string} userId - The user id\n     * @param {string} [token] - The authentication token\n     */\n    if (!feedSlug || !userId) {\n      throw new errors.FeedError('Please provide a feed slug and user id, ie client.feed(\"user\", \"1\")');\n    }\n\n    if (feedSlug.indexOf(':') !== -1) {\n      throw new errors.FeedError('Please initialize the feed using client.feed(\"user\", \"1\") not client.feed(\"user:1\")');\n    }\n\n    utils.validateFeedSlug(feedSlug);\n    utils.validateUserId(userId); // raise an error if there is no token\n\n    if (!this.apiSecret && !token) {\n      throw new errors.FeedError('Missing token, in client side mode please provide a feed secret');\n    }\n\n    this.client = client;\n    this.slug = feedSlug;\n    this.userId = userId;\n    this.id = this.slug + ':' + this.userId;\n    this.token = token;\n    this.feedUrl = this.id.replace(':', '/');\n    this.feedTogether = this.id.replace(':', '');\n    this.signature = this.feedTogether + ' ' + this.token; // faye setup\n\n    this.notificationChannel = 'site-' + this.client.appId + '-feed-' + this.feedTogether;\n    this.enrichByDefault = false;\n  },\n  addActivity: function addActivity(activity, callback) {\n    /**\n     * Adds the given activity to the feed and\n     * calls the specified callback\n     * @method addActivity\n     * @memberof StreamFeed.prototype\n     * @param {object} activity - The activity to add\n     * @param {requestCallback} callback - Callback to call on completion\n     * @return {Promise} Promise object\n     */\n    activity = replaceStreamObjects(activity);\n\n    if (!activity.actor && this.client.currentUser) {\n      activity.actor = this.client.currentUser._streamRef();\n    }\n\n    return this.client.post({\n      url: 'feed/' + this.feedUrl + '/',\n      body: activity,\n      signature: this.signature\n    }, callback);\n  },\n  removeActivity: function removeActivity(activityId, callback) {\n    /**\n     * Removes the activity by activityId\n     * @method removeActivity\n     * @memberof StreamFeed.prototype\n     * @param  {string}   activityId Identifier of activity to remove\n     * @param  {requestCallback} callback   Callback to call on completion\n     * @return {Promise} Promise object\n     * @example\n     * feed.removeActivity(activityId);\n     * @example\n     * feed.removeActivity({'foreignId': foreignId});\n     */\n    var identifier = activityId.foreignId ? activityId.foreignId : activityId;\n    var params = {};\n\n    if (activityId.foreignId) {\n      params['foreign_id'] = '1';\n    }\n\n    return this.client['delete']({\n      url: 'feed/' + this.feedUrl + '/' + identifier + '/',\n      qs: params,\n      signature: this.signature\n    }, callback);\n  },\n  addActivities: function addActivities(activities, callback) {\n    /**\n     * Adds the given activities to the feed and calls the specified callback\n     * @method addActivities\n     * @memberof StreamFeed.prototype\n     * @param  {Array}   activities Array of activities to add\n     * @param  {requestCallback} callback   Callback to call on completion\n     * @return {Promise}               XHR request object\n     */\n    activities = replaceStreamObjects(activities);\n    var data = {\n      activities: activities\n    };\n    var xhr = this.client.post({\n      url: 'feed/' + this.feedUrl + '/',\n      body: data,\n      signature: this.signature\n    }, callback);\n    return xhr;\n  },\n  follow: function follow(targetSlug, targetUserId, options, callback) {\n    /**\n     * Follows the given target feed\n     * @method follow\n     * @memberof StreamFeed.prototype\n     * @param  {string}   targetSlug   Slug of the target feed\n     * @param  {string}   targetUserId User identifier of the target feed\n     * @param  {object}   options      Additional options\n     * @param  {number}   options.activityCopyLimit Limit the amount of activities copied over on follow\n     * @param  {requestCallback} callback     Callback to call on completion\n     * @return {Promise}  Promise object\n     * @example feed.follow('user', '1');\n     * @example feed.follow('user', '1', callback);\n     * @example feed.follow('user', '1', options, callback);\n     */\n    if (targetUserId instanceof StreamUser) {\n      targetUserId = targetUserId.id;\n    }\n\n    utils.validateFeedSlug(targetSlug);\n    utils.validateUserId(targetUserId);\n    var activityCopyLimit;\n    var last = arguments[arguments.length - 1]; // callback is always the last argument\n\n    callback = last.call ? last : undefined;\n    var target = targetSlug + ':' + targetUserId; // check for additional options\n\n    if (options && !options.call) {\n      if (typeof options.limit !== 'undefined' && options.limit !== null) {\n        activityCopyLimit = options.limit;\n      }\n    }\n\n    var body = {\n      target: target\n    };\n\n    if (typeof activityCopyLimit !== 'undefined' && activityCopyLimit !== null) {\n      body['activity_copy_limit'] = activityCopyLimit;\n    }\n\n    return this.client.post({\n      url: 'feed/' + this.feedUrl + '/following/',\n      body: body,\n      signature: this.signature\n    }, callback);\n  },\n  unfollow: function unfollow(targetSlug, targetUserId, optionsOrCallback, callback) {\n    /**\n     * Unfollow the given feed\n     * @method unfollow\n     * @memberof StreamFeed.prototype\n     * @param  {string}   targetSlug   Slug of the target feed\n     * @param  {string}   targetUserId [description]\n     * @param  {requestCallback|object} optionsOrCallback\n     * @param  {boolean}  optionOrCallback.keepHistory when provided the activities from target\n     *                                                 feed will not be kept in the feed\n     * @param  {requestCallback} callback     Callback to call on completion\n     * @return {object}                XHR request object\n     * @example feed.unfollow('user', '2', callback);\n     */\n    var options = {},\n        qs = {};\n    if (typeof optionsOrCallback === 'function') callback = optionsOrCallback;\n    if (_typeof(optionsOrCallback) === 'object') options = optionsOrCallback;\n    if (typeof options.keepHistory === 'boolean' && options.keepHistory) qs['keep_history'] = '1';\n    utils.validateFeedSlug(targetSlug);\n    utils.validateUserId(targetUserId);\n    var targetFeedId = targetSlug + ':' + targetUserId;\n    var xhr = this.client['delete']({\n      url: 'feed/' + this.feedUrl + '/following/' + targetFeedId + '/',\n      qs: qs,\n      signature: this.signature\n    }, callback);\n    return xhr;\n  },\n  following: function following(options, callback) {\n    /**\n     * List which feeds this feed is following\n     * @method following\n     * @memberof StreamFeed.prototype\n     * @param  {object}   options  Additional options\n     * @param  {string}   options.filter Filter to apply on search operation\n     * @param  {requestCallback} callback Callback to call on completion\n     * @return {Promise} Promise object\n     * @example feed.following({limit:10, filter: ['user:1', 'user:2']}, callback);\n     */\n    if (options !== undefined && options.filter) {\n      options.filter = options.filter.join(',');\n    }\n\n    return this.client.get({\n      url: 'feed/' + this.feedUrl + '/following/',\n      qs: options,\n      signature: this.signature\n    }, callback);\n  },\n  followers: function followers(options, callback) {\n    /**\n     * List the followers of this feed\n     * @method followers\n     * @memberof StreamFeed.prototype\n     * @param  {object}   options  Additional options\n     * @param  {string}   options.filter Filter to apply on search operation\n     * @param  {requestCallback} callback Callback to call on completion\n     * @return {Promise} Promise object\n     * @example\n     * feed.followers({limit:10, filter: ['user:1', 'user:2']}, callback);\n     */\n    if (options !== undefined && options.filter) {\n      options.filter = options.filter.join(',');\n    }\n\n    return this.client.get({\n      url: 'feed/' + this.feedUrl + '/followers/',\n      qs: options,\n      signature: this.signature\n    }, callback);\n  },\n  get: function get(options, callback) {\n    /**\n     * Reads the feed\n     * @method get\n     * @memberof StreamFeed.prototype\n     * @param  {object}   options  Additional options\n     * @param  {requestCallback} callback Callback to call on completion\n     * @return {Promise} Promise object\n     * @example feed.get({limit: 10, id_lte: 'activity-id'})\n     * @example feed.get({limit: 10, mark_seen: true})\n     */\n    var path;\n\n    if (options && options['mark_read'] && options['mark_read'].join) {\n      options['mark_read'] = options['mark_read'].join(',');\n    }\n\n    if (options && options['mark_seen'] && options['mark_seen'].join) {\n      options['mark_seen'] = options['mark_seen'].join(',');\n    }\n\n    this.client.replaceReactionOptions(options);\n\n    if (this.client.shouldUseEnrichEndpoint(options)) {\n      path = 'enrich/feed/';\n    } else {\n      path = 'feed/';\n    }\n\n    return this.client.get({\n      url: path + this.feedUrl + '/',\n      qs: options,\n      signature: this.signature\n    }, callback);\n  },\n  getReadOnlyToken: function getReadOnlyToken() {\n    /**\n     * Returns a token that allows only read operations\n     *\n     * @deprecated since version 4.0\n     * @method getReadOnlyToken\n     * @memberof StreamClient.prototype\n     * @param {string} feedSlug - The feed slug to get a read only token for\n     * @param {string} userId - The user identifier\n     * @return {string} token\n     * @example\n     * client.getReadOnlyToken('user', '1');\n     */\n    var feedId = '' + this.slug + this.userId;\n    return signing.JWTScopeToken(this.client.apiSecret, '*', 'read', {\n      feedId: feedId,\n      expireTokens: this.client.expireTokens\n    });\n  },\n  getReadWriteToken: function getReadWriteToken() {\n    /**\n     * Returns a token that allows read and write operations\n     * @deprecated since version 4.0\n     * @method getReadWriteToken\n     * @memberof StreamClient.prototype\n     * @param {string} feedSlug - The feed slug to get a read only token for\n     * @param {string} userId - The user identifier\n     * @return {string} token\n     * @example\n     * client.getReadWriteToken('user', '1');\n     */\n    var feedId = '' + this.slug + this.userId;\n    return signing.JWTScopeToken(this.client.apiSecret, '*', '*', {\n      feedId: feedId,\n      expireTokens: this.client.expireTokens\n    });\n  },\n  getActivityDetail: function getActivityDetail(activityId, options, callback) {\n    /**\n     * Retrieves one activity from a feed and adds enrichment\n     * @method getActivityDetail\n     * @memberof StreamFeed.prototype\n     * @param  {string}   activityId Identifier of activity to retrieve\n     * @param  {object}   options  Additional options\n     * @param  {requestCallback} callback Callback to call on completion\n     * @return {Promise} Promise object\n     * @example feed.getActivityDetail(activityId)\n     * @example feed.getActivityDetail(activityId, {withRecentReactions: true})\n     * @example feed.getActivityDetail(activityId, {withReactionCounts: true})\n     * @example feed.getActivityDetail(activityId, {withOwnReactions: true, withReactionCounts: true})\n     */\n    return this.get(_extends({\n      id_lte: activityId,\n      id_gte: activityId,\n      limit: 1\n    }, options || {}), callback);\n  },\n  getFayeClient: function getFayeClient() {\n    /**\n     * Returns the current faye client object\n     * @method getFayeClient\n     * @memberof StreamFeed.prototype\n     * @access private\n     * @return {object} Faye client\n     */\n    return this.client.getFayeClient();\n  },\n  subscribe: function subscribe(callback) {\n    /**\n     * Subscribes to any changes in the feed, return a promise\n     * @method subscribe\n     * @memberof StreamFeed.prototype\n     * @param  {function} callback Callback to call on completion\n     * @return {Promise}           Promise object\n     * @example\n     * feed.subscribe(callback).then(function(){\n     * \t\tconsole.log('we are now listening to changes');\n     * });\n     */\n    if (!this.client.appId) {\n      throw new errors.SiteError('Missing app id, which is needed to subscribe, use var client = stream.connect(key, secret, appId);');\n    }\n\n    var subscription = this.getFayeClient().subscribe('/' + this.notificationChannel, callback);\n    this.client.subscriptions['/' + this.notificationChannel] = {\n      token: this.token,\n      userId: this.notificationChannel,\n      fayeSubscription: subscription\n    };\n    return subscription;\n  },\n  unsubscribe: function unsubscribe() {\n    /**\n     * Cancel updates created via feed.subscribe()\n     * @return void\n     */\n    var streamSubscription = this.client.subscriptions['/' + this.notificationChannel];\n\n    if (streamSubscription) {\n      delete this.client.subscriptions['/' + this.notificationChannel];\n      streamSubscription.fayeSubscription.cancel();\n    }\n  },\n  updateActivityToTargets: function updateActivityToTargets(foreign_id, time, new_targets, added_targets, removed_targets) {\n    /**\n     * Updates an activity's \"to\" fields\n     * @since 3.10.0\n     * @param {string} foreign_id The foreign_id of the activity to update\n     * @param {string} time The time of the activity to update\n     * @param {array} new_targets Set the new \"to\" targets for the activity - will remove old targets\n     * @param {array} added_targets Add these new targets to the activity\n     * @param {array} removed_targets Remove these targets from the activity\n     */\n    if (!foreign_id) {\n      throw new Error('Missing `foreign_id` parameter!');\n    } else if (!time) {\n      throw new Error('Missing `time` parameter!');\n    }\n\n    if (!new_targets && !added_targets && !removed_targets) {\n      throw new Error('Requires you to provide at least one parameter for `new_targets`, `added_targets`, or `removed_targets` - example: `updateActivityToTargets(\"foreignID:1234\", new Date(), [new_targets...], [added_targets...], [removed_targets...])`');\n    }\n\n    if (new_targets) {\n      if (added_targets || removed_targets) {\n        throw new Error(\"Can't include add_targets or removed_targets if you're also including new_targets\");\n      }\n    }\n\n    if (added_targets && removed_targets) {\n      // brute force - iterate through added, check to see if removed contains that element\n      for (var i = 0; i < added_targets.length; i++) {\n        // would normally use Array.prototype.includes here, but it's not supported in Node.js v4 :(\n        for (var j = 0; j < removed_targets.length; j++) {\n          if (removed_targets[j] == added_targets[i]) {\n            throw new Error(\"Can't have the same feed ID in added_targets and removed_targets.\");\n          }\n        }\n      }\n    }\n\n    var body = {\n      foreign_id: foreign_id,\n      time: time\n    };\n\n    if (new_targets) {\n      body['new_targets'] = new_targets;\n    }\n\n    if (added_targets) {\n      body['added_targets'] = added_targets;\n    }\n\n    if (removed_targets) {\n      body['removed_targets'] = removed_targets;\n    }\n\n    return this.client.post({\n      url: 'feed_targets/' + this.feedUrl + '/activity_to_targets/',\n      signature: this.signature,\n      body: body\n    });\n  }\n};\nmodule.exports = StreamFeed;","map":null,"metadata":{},"sourceType":"script"}