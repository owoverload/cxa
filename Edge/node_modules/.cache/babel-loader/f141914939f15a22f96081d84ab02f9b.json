{"ast":null,"code":"'use strict';\n\nvar Class = require('../util/class'),\n    Promise = require('../util/promise'),\n    Set = require('../util/set'),\n    URI = require('../util/uri'),\n    browser = require('../util/browser'),\n    copyObject = require('../util/copy_object'),\n    extend = require('../util/extend'),\n    toJSON = require('../util/to_json'),\n    ws = require('../util/websocket'),\n    Deferrable = require('../mixins/deferrable'),\n    Transport = require('./transport');\n\nvar WebSocket = extend(Class(Transport, {\n  UNCONNECTED: 1,\n  CONNECTING: 2,\n  CONNECTED: 3,\n  batching: false,\n  isUsable: function (callback, context) {\n    this.callback(function () {\n      callback.call(context, true);\n    });\n    this.errback(function () {\n      callback.call(context, false);\n    });\n    this.connect();\n  },\n  request: function (messages) {\n    this._pending = this._pending || new Set();\n\n    for (var i = 0, n = messages.length; i < n; i++) this._pending.add(messages[i]);\n\n    var self = this;\n    var promise = new Promise(function (resolve, reject) {\n      self.callback(function (socket) {\n        if (!socket || socket.readyState !== 1) return;\n        socket.send(toJSON(messages));\n        resolve(socket);\n      });\n      self.connect();\n    });\n    return {\n      abort: function () {\n        promise.then(function (ws) {\n          ws.close();\n        });\n      }\n    };\n  },\n  connect: function () {\n    if (WebSocket._unloaded) return;\n    this._state = this._state || this.UNCONNECTED;\n    if (this._state !== this.UNCONNECTED) return;\n    this._state = this.CONNECTING;\n\n    var socket = this._createSocket();\n\n    if (!socket) return this.setDeferredStatus('failed');\n    var self = this;\n\n    socket.onopen = function () {\n      if (socket.headers) self._storeCookies(socket.headers['set-cookie']);\n      self._socket = socket;\n      self._state = self.CONNECTED;\n      self._everConnected = true;\n\n      self._ping();\n\n      self.setDeferredStatus('succeeded', socket);\n    };\n\n    var closed = false;\n\n    socket.onclose = socket.onerror = function () {\n      if (closed) return;\n      closed = true;\n      var wasConnected = self._state === self.CONNECTED;\n      socket.onopen = socket.onclose = socket.onerror = socket.onmessage = null;\n      delete self._socket;\n      self._state = self.UNCONNECTED;\n      self.removeTimeout('ping');\n      var pending = self._pending ? self._pending.toArray() : [];\n      delete self._pending;\n\n      if (wasConnected || self._everConnected) {\n        self.setDeferredStatus('unknown');\n\n        self._handleError(pending, wasConnected);\n      } else {\n        self.setDeferredStatus('failed');\n      }\n    };\n\n    socket.onmessage = function (event) {\n      var replies;\n\n      try {\n        replies = JSON.parse(event.data);\n      } catch (error) {}\n\n      if (!replies) return;\n      replies = [].concat(replies);\n\n      for (var i = 0, n = replies.length; i < n; i++) {\n        if (replies[i].successful === undefined) continue;\n\n        self._pending.remove(replies[i]);\n      }\n\n      self._receive(replies);\n    };\n  },\n  close: function () {\n    if (!this._socket) return;\n\n    this._socket.close();\n  },\n  _createSocket: function () {\n    var url = WebSocket.getSocketUrl(this.endpoint),\n        headers = this._dispatcher.headers,\n        extensions = this._dispatcher.wsExtensions,\n        cookie = this._getCookies(),\n        tls = this._dispatcher.tls,\n        options = {\n      extensions: extensions,\n      headers: headers,\n      proxy: this._proxy,\n      tls: tls\n    };\n\n    if (cookie !== '') options.headers['Cookie'] = cookie;\n    return ws.create(url, [], options);\n  },\n  _ping: function () {\n    if (!this._socket || this._socket.readyState !== 1) return;\n\n    this._socket.send('[]');\n\n    this.addTimeout('ping', this._dispatcher.timeout / 2, this._ping, this);\n  }\n}), {\n  PROTOCOLS: {\n    'http:': 'ws:',\n    'https:': 'wss:'\n  },\n  create: function (dispatcher, endpoint) {\n    var sockets = dispatcher.transports.websocket = dispatcher.transports.websocket || {};\n    sockets[endpoint.href] = sockets[endpoint.href] || new this(dispatcher, endpoint);\n    return sockets[endpoint.href];\n  },\n  getSocketUrl: function (endpoint) {\n    endpoint = copyObject(endpoint);\n    endpoint.protocol = this.PROTOCOLS[endpoint.protocol];\n    return URI.stringify(endpoint);\n  },\n  isUsable: function (dispatcher, endpoint, callback, context) {\n    this.create(dispatcher, endpoint).isUsable(callback, context);\n  }\n});\nextend(WebSocket.prototype, Deferrable);\nif (browser.Event && global.onbeforeunload !== undefined) browser.Event.on(global, 'beforeunload', function () {\n  WebSocket._unloaded = true;\n});\nmodule.exports = WebSocket;","map":null,"metadata":{},"sourceType":"script"}