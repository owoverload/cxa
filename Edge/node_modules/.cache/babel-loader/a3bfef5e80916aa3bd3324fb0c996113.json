{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _configs = require('./configs');\n\nvar _configs2 = _interopRequireDefault(_configs);\n\nvar _extractUrlsWithIndices = require('./extractUrlsWithIndices');\n\nvar _extractUrlsWithIndices2 = _interopRequireDefault(_extractUrlsWithIndices);\n\nvar _getCharacterWeight = require('./lib/getCharacterWeight');\n\nvar _getCharacterWeight2 = _interopRequireDefault(_getCharacterWeight);\n\nvar _hasInvalidCharacters = require('./hasInvalidCharacters');\n\nvar _hasInvalidCharacters2 = _interopRequireDefault(_hasInvalidCharacters);\n\nvar _modifyIndicesFromUTF16ToUnicode = require('./modifyIndicesFromUTF16ToUnicode');\n\nvar _modifyIndicesFromUTF16ToUnicode2 = _interopRequireDefault(_modifyIndicesFromUTF16ToUnicode);\n\nvar _twemojiParser = require('twemoji-parser');\n\nvar _urlHasHttps = require('./regexp/urlHasHttps');\n\nvar _urlHasHttps2 = _interopRequireDefault(_urlHasHttps);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * [parseTweet description]\n * @param  {string} text tweet text to parse\n * @param  {Object} options config options to pass\n * @return {Object} Fields in response described below:\n *\n * Response fields:\n * weightedLength {int} the weighted length of tweet based on weights specified in the config\n * valid {bool} If tweet is valid\n * permillage {float} permillage of the tweet over the max length specified in config\n * validRangeStart {int} beginning of valid text\n * validRangeEnd {int} End index of valid part of the tweet text (inclusive) in utf16\n * displayRangeStart {int} beginning index of display text\n * displayRangeEnd {int} end index of display text (inclusive) in utf16\n */\n// TODO: WEB-19861 Replace with public package after it is open sourced\n\n\nvar parseTweet = function parseTweet() {\n  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _configs2.default.defaults;\n  var mergedOptions = Object.keys(options).length ? options : _configs2.default.defaults;\n  var defaultWeight = mergedOptions.defaultWeight,\n      emojiParsingEnabled = mergedOptions.emojiParsingEnabled,\n      scale = mergedOptions.scale,\n      maxWeightedTweetLength = mergedOptions.maxWeightedTweetLength,\n      transformedURLLength = mergedOptions.transformedURLLength;\n  var normalizedText = typeof String.prototype.normalize === 'function' ? text.normalize() : text; // Hash all entities by their startIndex for fast lookup\n\n  var urlEntitiesMap = transformEntitiesToHash((0, _extractUrlsWithIndices2.default)(normalizedText));\n  var emojiEntitiesMap = emojiParsingEnabled ? transformEntitiesToHash((0, _twemojiParser.parse)(normalizedText)) : [];\n  var tweetLength = normalizedText.length;\n  var weightedLength = 0;\n  var validDisplayIndex = 0;\n  var valid = true; // Go through every character and calculate weight\n\n  for (var charIndex = 0; charIndex < tweetLength; charIndex++) {\n    // If a url begins at the specified index handle, add constant length\n    if (urlEntitiesMap[charIndex]) {\n      var _urlEntitiesMap$charI = urlEntitiesMap[charIndex],\n          url = _urlEntitiesMap$charI.url,\n          indices = _urlEntitiesMap$charI.indices;\n      weightedLength += transformedURLLength * scale;\n      charIndex += url.length - 1;\n    } else if (emojiParsingEnabled && emojiEntitiesMap[charIndex]) {\n      var _emojiEntitiesMap$cha = emojiEntitiesMap[charIndex],\n          emoji = _emojiEntitiesMap$cha.text,\n          _indices = _emojiEntitiesMap$cha.indices;\n      weightedLength += (0, _getCharacterWeight2.default)(emoji.charAt(0), mergedOptions);\n      charIndex += emoji.length - 1;\n    } else {\n      charIndex += isSurrogatePair(normalizedText, charIndex) ? 1 : 0;\n      weightedLength += (0, _getCharacterWeight2.default)(normalizedText.charAt(charIndex), mergedOptions);\n    } // Only test for validity of character if it is still valid\n\n\n    if (valid) {\n      valid = !(0, _hasInvalidCharacters2.default)(normalizedText.substring(charIndex, charIndex + 1));\n    }\n\n    if (valid && weightedLength <= maxWeightedTweetLength * scale) {\n      validDisplayIndex = charIndex;\n    }\n  }\n\n  weightedLength = weightedLength / scale;\n  valid = valid && weightedLength > 0 && weightedLength <= maxWeightedTweetLength;\n  var permillage = Math.floor(weightedLength / maxWeightedTweetLength * 1000);\n  var normalizationOffset = text.length - normalizedText.length;\n  validDisplayIndex += normalizationOffset;\n  return {\n    weightedLength: weightedLength,\n    valid: valid,\n    permillage: permillage,\n    validRangeStart: 0,\n    validRangeEnd: validDisplayIndex,\n    displayRangeStart: 0,\n    displayRangeEnd: text.length > 0 ? text.length - 1 : 0\n  };\n}; // Copyright 2018 Twitter, Inc.\n// Licensed under the Apache License, Version 2.0\n// http://www.apache.org/licenses/LICENSE-2.0\n\n\nvar transformEntitiesToHash = function transformEntitiesToHash(entities) {\n  return entities.reduce(function (map, entity) {\n    map[entity.indices[0]] = entity;\n    return map;\n  }, {});\n};\n\nvar isSurrogatePair = function isSurrogatePair(text, cIndex) {\n  // Test if a character is the beginning of a surrogate pair\n  if (cIndex < text.length - 1) {\n    var c = text.charCodeAt(cIndex);\n    var cNext = text.charCodeAt(cIndex + 1);\n    return 0xd800 <= c && c <= 0xdbff && 0xdc00 <= cNext && cNext <= 0xdfff;\n  }\n\n  return false;\n};\n\nexports.default = parseTweet;\nmodule.exports = exports['default'];","map":null,"metadata":{},"sourceType":"script"}